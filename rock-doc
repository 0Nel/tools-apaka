#! /usr/bin/env ruby

require 'autoproj'
require 'autoproj/cmdline'

Autoproj::CmdLine.initialize_and_load
manifest = Autoproj.manifest

output_dir = ARGV.shift
if !output_dir
    exit(1)
end

def render_item(name, value = nil)
    if value
        "<li><b>#{name}</b>: #{value}</li>"
    else
        "<li><b>#{name}</b></li>"
    end
end

def render_vcs(vcs)
    value = [['type', vcs.type], ['url', vcs.url]].concat(vcs.options.to_a.sort_by { |k, _| k.to_s })
    value = value.map do |key, value|
        if value.respond_to?(:to_str) && File.file?(value)
            value = Pathname.new(value).relative_path_from(Pathname.new(Autoproj.root_dir))
        elsif value =~ /git:\/\/(.*)\.git/
            value = "<a href=\"http://#{$1}\">#{value}</a>"
        end
        "<tr><td>#{key}</td><td>#{value}</td></tr>"
    end.join("\n")
    value = "<table>#{value}</table>"
end

def package_set_header(pkg_set)
    result = []
    result << ['name', pkg_set.name]

    if pkg_set.empty?
        result << ['is empty']
        return result.map { |v| render_item(*v) }
    end

    result << ["from", render_vcs(pkg_set.vcs)]

    imports = pkg_set.each_imported_set.to_a
    if !imports.empty?
        imports.each do |imported_set|
            result << ["imports", package_set_link(imported_set.name)]
        end
    end


    set_packages = pkg_set.each_package.sort_by(&:name)
    set_packages = set_packages.map do |pkg|
        package_link(pkg.name)
    end
    result << ['packages', set_packages.join(", ")]
    result << ['osdeps', pkg_set.each_osdep.map(&:first).sort.map { |name| osdeps_link(name) }.join(", ")]

    result.map { |v| render_item(*v) }
end

def package_set_link(name)
    link = "../package_sets_#{name.gsub(/[^\w]/, '_')}/index.html"
    "<a href=\"#{link}\">#{name}</a>"
end
def package_link(name)
    link = "../#{name.gsub(/[^\w]/, '_')}/index.html"
    "<a href=\"#{link}\">#{name}</a>"
end
def osdeps_link(name)
    link = "../osdeps_#{name.gsub(/[^\w]/, '_')}/index.html"
    "<a href=\"#{link}\">#{name}</a>"
end
def file_link(file)
    if file == Autoproj::OSDependencies::AUTOPROJ_OSDEPS
        "autoproj's default OSdeps file"
    elsif file =~ /autoproj\/remotes\/([^\/]+)\/(.*)/
        pkg_set_name, file_name = $1, $2
        "#{package_set_link($1)}/#{$2}"
    end
end


root_metainfo = []

sort_order = 0

package_sets = manifest.each_package_set
package_sets.each do |pkg_set|
    next if pkg_set.local?

    page = <<-EOT
---
title: #{pkg_set.name}
sort_info: #{sort_order += 1}
---
<div class="body-header-list" markdown="1">
<ul>
    #{package_set_header(pkg_set).join("\n    ")}
</ul>
</div>
    EOT

    pkg_set_dir = File.join('package_sets_' + pkg_set.name.gsub(/[^\w]/, '_'))
    root_metainfo << [pkg_set_dir, pkg_set.name, sort_order]

    pkg_set_dir = File.join(output_dir, pkg_set_dir)
    FileUtils.mkdir_p(pkg_set_dir)
    File.open(File.join(pkg_set_dir, 'index.page'), 'w') do |io|
        io.puts page
    end
end

all_packages = Hash.new
package_sets.each do |pkg_set|
    next if pkg_set.local?

    pkg_set.each_package.each do |pkg|
        all_packages[pkg.name] = [pkg, pkg_set.name]
    end
end

def package_header(pkg, pkg_set)
    vcs_def = Autoproj.manifest.importer_definition_for(pkg.name)

    result = []
    result << ['defined in', package_set_link(pkg_set)]
    result << ["from", render_vcs(vcs_def)]

    opt_deps = pkg.optional_dependencies.to_set
    real_deps = pkg.dependencies.find_all { |dep_name| !opt_deps.include?(dep_name) }

    real_deps = real_deps.sort.map do |name|
        package_link(name)
    end
    opt_deps = opt_deps.sort.map do |name|
        package_link(name)
    end

    if real_deps.empty?
        result << ['mandatory dependencies', 'none']
    else
        result << ['mandatory dependencies', real_deps.join(", ")]
    end
    if opt_deps.empty?
        result << ['optional dependencies', 'none']
    else
        result << ['optional dependencies', opt_deps.join(", ")]
    end

    osdeps = pkg.os_packages.sort.
        map do |name|
            osdeps_link(name)
        end
    if osdeps.empty?
        result << ['OS dependencies', 'none']
    else
        result << ['OS dependencies', osdeps.join(", ")]
    end

    return result.map { |v| render_item(*v) }
end

all_packages.to_a.sort_by(&:first).map(&:last).each do |pkg, pkg_set|
    if File.exists?(File.join(pkg.srcdir, "manifest.xml"))
        manifest.load_package_manifest(pkg.name)
        manifest.resolve_optional_dependencies
    end
    pkg_manifest = Autoproj.manifest.package_manifests[pkg.name];
    documentation =
        if pkg_manifest
            pkg_manifest.documentation
        end
    if !documentation || documentation.empty?
        documentation = "#{pkg.name} has no manifest"
    end
    documentation = documentation.split("\n").map(&:strip).join("\n")

    page = <<-EOT
---
title: #{pkg.name}
sort_info: #{sort_order += 1}
---
<div class="body-header-list" markdown="1">
<ul>
    #{package_header(pkg, pkg_set).join("\n    ")}
</ul>
</div>

Documentation
-------------
#{documentation}
    EOT

    pkg_dir = File.join(pkg.name.gsub(/[^\w]/, '_'))
    root_metainfo << [pkg_dir, pkg.name, sort_order]
    pkg_dir = File.join(output_dir, pkg_dir)

    FileUtils.mkdir_p(pkg_dir)
    File.open(File.join(pkg_dir, 'index.page'), 'w') do |io|
        io.puts page
    end
end

osdeps = Autoproj.osdeps
osdeps.all_definitions.sort_by(&:first).each do |name, data|
    data = data.map do |files, info|
        if info.kind_of?(Hash)
            info = YAML.dump(info).split("\n")
            info.shift
            info = info.join("\n      ")
        end
        "**Defined in** #{files.map { |f| file_link(f) }.join(", ")} **as**\n\n    #{name}:\n      #{info}"
    end

    page = <<-EOT
---
title: #{name}
sort_info: #{sort_order += 1}
---
#{data.join("\n")}
    EOT

    dir = "osdeps_#{name.gsub(/[^\w]/, '_')}"
    root_metainfo << [dir, name, sort_order]
    dir = File.join(output_dir, dir)
    FileUtils.mkdir_p dir
    File.open(File.join(dir, "index.page"), 'w') do |io|
        io.puts page
    end
end

File.open(File.join(output_dir, 'htmldoc.metainfo'), 'w') do |io|
    root_metainfo.each do |dir, title, sort|
        io.puts "#{dir}:"
        io.puts "  title: #{title}"
        io.puts "  routed_title: #{title}"
        io.puts "  sort_info: #{sort}"
        io.puts
    end
end

